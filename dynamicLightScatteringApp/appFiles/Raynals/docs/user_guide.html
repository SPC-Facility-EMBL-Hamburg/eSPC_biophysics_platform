<!DOCTYPE html>
<html lang="en" class="vf-no-js" >
<head>
  <script>
  // Detect if JS is on and swap vf-no-js for vf-js on the html element
  (function(H){H.className=H.className.replace(/\bvf-no-js\b/,'vf-js')})(document.documentElement);
  </script>
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <link rel="stylesheet" media="all" href="https://assets.emblstatic.net/vf/v2.4.5/css/styles.css">
  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: {
      equationNumbers: { autoNumber: "ams" },
      tagSide: "right"
    },
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  })
</script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  
    <style>
        .whitespace-preserve {
            white-space: pre; /* Preserve line breaks and spaces */
             display: inline-block;
             margin-top:0px;
            /* Add any other CSS styling you want to apply to the preformatted text */
        }
    </style>

</head>

<body class="vf-body vf-stack"><script id="__bs_script__">//<![CDATA[
    document.write("<script async src='/browser-sync/browser-sync-client.js?v=2.26.14'><\/script>".replace("HOST", location.hostname));
//]]></script>


<section class="vf-intro" id="an-id-for-anchor">

  <div class="vf-stack">

    <p class="vf-intro__text">Use Raynals to assess sample dispersity and compare the quality of different samples.</p>

<div class="vf-section-header"><a class="vf-section-header__heading vf-section-header__heading--is-link" href="JavaScript:Void(0);" id="section-link" onclick="myFunction('inputFile')">Input file <svg aria-hidden="true" class="vf-section-header__icon | vf-icon vf-icon-arrow--inline-end" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 12c0 6.627 5.373 12 12 12s12-5.373 12-12S18.627 0 12 0C5.376.008.008 5.376 0 12zm13.707-5.209l4.5 4.5a1 1 0 010 1.414l-4.5 4.5a1 1 0 01-1.414-1.414l2.366-2.367a.25.25 0 00-.177-.424H6a1 1 0 010-2h8.482a.25.25 0 00.177-.427l-2.366-2.368a1 1 0 011.414-1.414z" fill="" fill-rule="nonzero"></path>
    </svg></a></div>
    
<div id="inputFile" style="display:none">
  
      <p class="vf-intro__text">The following types of input files can be loaded: 
    </p>
  
    <p class="vf-intro__text">1) Load a <a href="220315CA_5_replicates.csv" download>csv</a> with headers where the first column contains the time data and all subsequent columns the autocorrelation data of the samples. 
    </p>
    
    <p class="vf-intro__text">2) Load a <a href="proteinX.zip" download>compressed file (.7z or .zip)</a> containing many Excel files (.xlsx). 
Each sample should have its own Excel file. The DLS data, which includes time and autocorrelation values, should be located in the first two columns. The header of the first column must be either 'tau' or 'time'. Sample names will be read from the Excel files. 
    </p>
   
       <p class="vf-intro__text" style="margin-bottom: 0;">If the <a href="test_export_panta.zip" download>compressed file</a> contains folders named 'Acquisition #', autocorrelation curves will be automatically averaged. For example, the following directory structure will load two curves to Raynals:</p>
       
      <div class="whitespace-preserve">
        <p class="vf-intro__text">
└── pH_4_proteinX 
    ├── Replicate 1
    │   ├── Acquisition 1
    │   │   ├── pH_4_proteinX - 1_acf.xlsx
    │   ├── Acquisition 2
    │   │   ├── pH_4_proteinX - 1_acf.xlsx
    │   ├── Acquisition 3
    │   │   ├── pH_4_proteinX - 1_acf.xlsx
    └── Replicate 2
        ├── Acquisition 1
        │   ├── pH_4_proteinX - 2_acf.xlsx
        ├── Acquisition 2
        │   ├── pH_4_proteinX - 2_acf.xlsx
        ├── Acquisition 3
        │   ├── pH_4_proteinX - 2_acf.xlsx
    </p></div>
    
          <p class="vf-intro__text">General details:</p>
    
    <p class="vf-intro__text">The time units should be either seconds or microseconds. If several measurements were done for the same sample (i.e., five scans of the same plate), specify this information in the 'Files metadata' Table inside the 'Input' box. The value of the autocorrelation baseline should be 1 (if it's 0, we will add 1). 
</p>

</div>

<div class="vf-section-header"><a class="vf-section-header__heading vf-section-header__heading--is-link" href="JavaScript:Void(0);" id="section-link" onclick="myFunction('inputParams')">Input parameters <svg aria-hidden="true" class="vf-section-header__icon | vf-icon vf-icon-arrow--inline-end" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 12c0 6.627 5.373 12 12 12s12-5.373 12-12S18.627 0 12 0C5.376.008.008 5.376 0 12zm13.707-5.209l4.5 4.5a1 1 0 010 1.414l-4.5 4.5a1 1 0 01-1.414-1.414l2.366-2.367a.25.25 0 00-.177-.424H6a1 1 0 010-2h8.482a.25.25 0 00.177-.427l-2.366-2.368a1 1 0 011.414-1.414z" fill="" fill-rule="nonzero"></path>
    </svg></a></div>
    
<div id="inputParams" style="display:none">
  
<p class="vf-intro__text"> <b>Several parameters need to be specified for each experiment: Wavelength of the laser, angle of the detector, temperature, refractive index & viscosity.</b> The first two values depend on the instrument. For example, for a Wyatt Dynapro Plate Reader, these are 817 nm and 150°, for a 
Wyatt DynaPro NanoStar, 658 nm and 90°, and for the Nanotemper Prometheus Panta, 405 nm and 147°. Regarding the temperature, refractive index and viscosity, we'll use as default 20°C, 1.33 (pure water) and 8.9e-4 pascal-second (pure water).
</p>

<p class="vf-intro__text">
For the sake of speed optimization, the DLS data is filtered before creating the Autocorrelation plots (all data is used for fitting!). The filter is based on returning no more than 80 points evenly spaced on a log scale with base 1.5.
</p>

<br> 

</div>

<div class="vf-section-header"><a class="vf-section-header__heading vf-section-header__heading--is-link" href="JavaScript:Void(0);" id="section-link" onclick="myFunction('Filters')">Filters<svg aria-hidden="true" class="vf-section-header__icon | vf-icon vf-icon-arrow--inline-end" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 12c0 6.627 5.373 12 12 12s12-5.373 12-12S18.627 0 12 0C5.376.008.008 5.376 0 12zm13.707-5.209l4.5 4.5a1 1 0 010 1.414l-4.5 4.5a1 1 0 01-1.414-1.414l2.366-2.367a.25.25 0 00-.177-.424H6a1 1 0 010-2h8.482a.25.25 0 00.177-.427l-2.366-2.368a1 1 0 011.414-1.414z" fill="" fill-rule="nonzero"></path>
    </svg></a></div>
    
<div id="Filters" style="display:none">
  
    <p class="vf-intro__text">The autocorrelation curves can be filtered to remove samples with a low initial signal, which may correspond to clean buffers. Similarly, samples where the return to baseline occurs too late, indicating that the amount of aggregates (or dust) prevents any meaningful DLS data analysis, can also be excluded. An example of these two filters is provided below:
    </p>
    
    <br>
    
<figure class="vf-figure vf-figure--align vf-figure--align-centered">
<img src="raynalsFilterExample.png" alt="Raynals filters example" width="900" loading="lazy"/>
</figure>
    
</div>

<div class="vf-section-header"><a class="vf-section-header__heading vf-section-header__heading--is-link" href="JavaScript:Void(0);" id="section-link" onclick="myFunction('Model')">Models<svg aria-hidden="true" class="vf-section-header__icon | vf-icon vf-icon-arrow--inline-end" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 12c0 6.627 5.373 12 12 12s12-5.373 12-12S18.627 0 12 0C5.376.008.008 5.376 0 12zm13.707-5.209l4.5 4.5a1 1 0 010 1.414l-4.5 4.5a1 1 0 01-1.414-1.414l2.366-2.367a.25.25 0 00-.177-.424H6a1 1 0 010-2h8.482a.25.25 0 00.177-.427l-2.366-2.368a1 1 0 011.414-1.414z" fill="" fill-rule="nonzero"></path>
    </svg></a></div>
    
<div id="Model" style="display:none">
  
<div class="vf-links">
  <ul class="vf-links__list | vf-list">
    
    <li class="vf-list__item">
      <a class="vf-list__link" onclick="myFunction('Theory')" href="JavaScript:Void(0);">
       Theory
      </a>
    </li>

  <div id="Theory" style="display:none">

    <p class="vf-intro__text">In a DLS experiment, we measure the intensity correlation function (or second-order correlation function). This function, also called \( G_{2}(\tau) \), can be expressed as an integral over the product of intensities at time \( t \) and delayed time \( t + \tau  \) :</p>

\begin{equation}
\large{ 
    G_{2}(\tau) = \langle I(t)I(t+\tau) \rangle
   }
\end{equation}

<p class="vf-intro__text">where \( \tau  \) is the lag time between two time points. The normalised
version of \( G_{2}(\tau) \) can be expressed as </p>

\begin{equation}
\large{ 
    g_{2}(\tau) = \frac{\langle I(t)I(t+\tau) \rangle}{ {\langle I(t)\rangle}^2 }
   }
\end{equation}

<p class="vf-intro__text">Then, \( g_{2}(\tau) \) <strong>(input data for the Raynals app)</strong> can be related to the normalised first-order correlation function \( g_{1}(\tau) \)
, which contains information about the motion of the particles, by the Siegert equation:  </p>


\begin{equation}
\large{ 
    g_{2}(\tau) = 1 + \beta {  \vert g_{1}(\tau)  \vert }^2
   }
\end{equation}

<p class="vf-intro__text">where \( \beta  \) is the coherence factor that depends on the instrument and the scattering properties of macromolecules. </p>

<p class="vf-intro__text">
For monodisperse particles,  \( g_{1}(\tau) \) decays exponentially and depends one decay constant. For a polydisperse system, \( g_{1}(\tau) \) is represented by an intensity-weighted integral over a distribution of decay rates \( G(\Gamma) \):  
</p>

\begin{equation}
\large{ 
    g_{1}(\tau) = \int_{0}^{\infty} G(\Gamma) \exp{(-\Gamma_{\tau}d\Gamma)}
   }
\end{equation}

<p class="vf-intro__text">
Each decay rate can be associated to a certain diffusion factor \( D \)
(units are \( m^2 / s \)) using the following equations:  
</p>

\begin{equation}
\large{ 
    D(s,q) = 1 / (s*(q^2)) 
   }
\end{equation}

<p class="vf-intro__text">
where \( s \) is the inverse of the decay rate and \( q \) is the 
Bragg wave vector defined as 
</p>

\begin{equation}
\large{ 
    q(\lambda,\eta,\theta) = \eta4\pi \lambda^{-1} \sin \frac{\theta}{2} 
   }
\end{equation}

<p class="vf-intro__text">
where \( \lambda \) is the wavelength of the incident light,  \( \theta \) is
the angle at which the detector is placed, and \( \eta \) is the solvent refractive index.
</p>

<p class="vf-intro__text">
Finally, the diffusion factor \( D \)  can be converted to hydrodynamic radius \( H_r \)  using 
</p>

\begin{equation}
\large{ 
    H_r(D,temperature,viscosity) = k_b*temperature / (6 \pi * viscosity * D)
   }
\end{equation}

<p class="vf-intro__text">
where \( k_b \) is the Boltzman constant (1.38e-23). Viscosity units are \( pascal-second \)
</p>

<br>

</div>

    <li class="vf-list__item">
      <a class="vf-list__link" onclick="myFunction('Fitting')" href="JavaScript:Void(0);">
      Fitting
      </a>
    </li>

  <div id="Fitting" style="display:none">

<p class="vf-intro__text">
<b>Tikhonov-Philips regularised inversion</b>
</p>

<p class="vf-intro__text">
Raynals fits the data (\( g_1 \)) based on the Tikhonov-Philips regularised inversion. To discretize the hydrodynamic radius space we use \( n \) (i.e., 200) points evenly spaced in a log scale. 
</p>

<p class="vf-intro__text">
First, \( \beta \) can be estimated as the intercept of \( g_{2} \) at time 0. 
This is done by fitting a polynomial of degree 2 to the DLS data at times shorter than
5 μs.
</p>

<p class="vf-intro__text">
Then, \( \beta \) is used to obtain \( g_{1} \) (See Theory Section).
</p>

\begin{equation}
\large{ 
    g_{1} = \sqrt{ (g_{2}-1) / \beta }
   }
\end{equation}

<p class="vf-intro__text">
Due to experimental errors, \( g_{2}-1 \) may be negative. All data after the first point where 
the square root can't be evaluated is removed from the analysis. 
</p>

<p class="vf-intro__text">
After obtaining \( g_{1} \), the equation that we need to fit is 
</p>

\begin{equation}
\large{ 
    g_{1}(t) = \sum_{i=1}^{200} c_i exp{\frac{-t}{s_i}}
   }
\end{equation}

<p class="vf-intro__text">
subject to 
</p>

\begin{equation}
\large{ 
    \sum_{i=1}^{200} c_i = 1 , c_i > 0
   }
\end{equation}

<p class="vf-intro__text">
where \( c_i \) is the i-th contribution of the i-th (inverse) decay rate. 
In mathematical terms, we need to get \( x \) minimizing
</p>

\begin{equation}
\large{ 
    \vert \vert Ax - b \vert \vert
   }
\end{equation}

<p class="vf-intro__text">
where \( x \) is the vector of contributions of 200 (inverse) decay rates, 
b is the vector \( g_1 \) of dimension \( n \), \( n \) is the number of data points, 
and \( A  \) is the kernel of dimensions \( n * 200 \) :  
</p>

\begin{equation}
\large{ 
    A_{j,k} = \exp{(\frac{-t_k}{s_j})}
   }
\end{equation}

<p class="vf-intro__text">
where \( j  \) and \( k  \) iterate over the inverse decay rate vector and time vector, respectively.
</p>

<p class="vf-intro__text">
Due to the ill-condition nature of the problem, we need to add a regularization term:
</p>

\begin{equation}
\large{ 
    \vert \vert Ax - b \vert \vert + \alpha \vert \vert Mx \vert \vert 
   }
\end{equation}

<p class="vf-intro__text">
where \( \alpha \) is a regularization parameter 
and \( M \) is a pre-conditioning matrix. In our case, \( M \) forces the obtained distribution of decay rates to be smooth and is equal to minimizing
</p>

\begin{equation}
\large{ 
   \vert \vert \sum_{i=1}^{200} c_i exp{\frac{-t}{s_i}} - g_{1}(t) \vert \vert
   + \alpha \vert \vert \sum_{i=2}^{199} 2c_i - c_{i-1} - c_{i+1} \vert \vert
   }
\end{equation}

<p class="vf-intro__text">
<b>The L-curve method to select the regularisation parameter</b>
</p>

<p class="vf-intro__text">
When the amount of noise in the data is unknown, several empirical criteria exist
to determine the "optimal" regularisation parameter. The L-curve criterion is one of them and consists of selecting the value of \( \alpha \) that lies on the corner of
the log-log plot of the penalty (\( \vert \vert Mx \vert \vert \)) versus fidelity (\( \vert \vert Ax - b \vert \vert \)) terms. 
</p>

<p class="vf-intro__text">
The values of \( \alpha \) that we want to evaluate can be selected using the 'Analysis' box inside the 'Analysis' Tab. The corner of the L-curve is then detected by implementing the numerical recipe provided in <a href="https://www.sciencedirect.com/science/article/abs/pii/S0168927401001799" target="_blank">Castellanos <i> et al.</i>, 2002</a>.
</p>

</div>
</ul>
</div>
</div>

<div class="vf-section-header"><a class="vf-section-header__heading vf-section-header__heading--is-link" href="JavaScript:Void(0);" id="section-link" onclick="myFunction('Simulation')">Simulation<svg aria-hidden="true" class="vf-section-header__icon | vf-icon vf-icon-arrow--inline-end" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 12c0 6.627 5.373 12 12 12s12-5.373 12-12S18.627 0 12 0C5.376.008.008 5.376 0 12zm13.707-5.209l4.5 4.5a1 1 0 010 1.414l-4.5 4.5a1 1 0 01-1.414-1.414l2.366-2.367a.25.25 0 00-.177-.424H6a1 1 0 010-2h8.482a.25.25 0 00.177-.427l-2.366-2.368a1 1 0 011.414-1.414z" fill="" fill-rule="nonzero"></path>
    </svg></a></div>

<div id="Simulation" style="display:none">
  
    <p class="vf-intro__text">
  All simulated data is based on non-interacting spherical particles 
  surrounded by a non-absorbing medium. The minimum and maximum allowed hydrodynamic radius are 0.09 and 1e6 nm.
  </p>
  
<br>  
  
<div class="vf-links">
  <ul class="vf-links__list | vf-list">
    
    <li class="vf-list__item">
      <a class="vf-list__link" onclick="myFunction('NumberD')" href="JavaScript:Void(0);">
       Number distribution
      </a>
    </li>

  <div id="NumberD" style="display:none">

    <p class="vf-intro__text">The number distribution depends only on how many particles we have for the different sizes. As an example, if we have 9990 particles with a hydrodynamic radius (Rh) of 5 nm and 10 particles with a Rh of 50 nm. The relative contribution will be 99.9 % and 0.1 %, respectively.</p>

<br>

</div>

    <li class="vf-list__item">
      <a class="vf-list__link" onclick="myFunction('volumeD')" href="JavaScript:Void(0);">
      Volume distribution
      </a>
    </li>

  <div id="volumeD" style="display:none">

    <p class="vf-intro__text">The volume distribution depends on how much our particles contribute to the total volume. As an example, if we have 9990 spheric particles with a Rh of 5 nm and 10 particles with a Rh of 50 nm. The relative contribution (to the total volume) will be 50 % and 50 %, respectively.</p>
    
<br>
</div>

    <li class="vf-list__item">
      <a class="vf-list__link" onclick="myFunction('intensityD')" href="JavaScript:Void(0);">
      Intensity distribution
      </a>
    </li>

  <div id="intensityD" style="display:none">

    <p class="vf-intro__text">The intensity distribution is based on the light scattered by the spheric particles. The intensity values are calculated using the Mie Theory (implemented in the <a href="https://miepython.readthedocs.io" target="_blank">Miepython package</a>) and depend on the following parameters: angle of detection (°), wavelength (nanometers) & refractive index (unitless). For small particles (size < wavelength/10), the amount of scattered light follows the Rayleigh Theory and scales to the sixth power of the radius.</p>
    
<br>
</div>

    <li class="vf-list__item">
      <a class="vf-list__link" onclick="myFunction('correlation')" href="JavaScript:Void(0);">
      Autocorrelation curve
      </a>
    </li>

  <div id="correlation" style="display:none">

  <p class="vf-intro__text">
  To simulate the autocorrelation curve we need the decay rates and the corresponding relative contributions (Equation 9, Fitting Subsection, Models Section). For this purpouse, we transform first each the hydrodynamic radius into a diffusion coefficient using the selected temperature & viscosity, and then into decay rates using the calculated Bragg wave vector (Equation 6, Theory Subsection, Models Section).
  </p>

<br>

</div>

</ul>

</div>
</div>
</div>
</section>

  <!-- IE11 polyfill JS -->
  <script nomodule crossorigin="anonymous" src="https://polyfill.io/v3/polyfill.min.js?flags=gated&features=default"></script>
  <script src="https://assets.emblstatic.net/vf/v2.4.5/scripts/scripts.js"></script>
  
  <!-- Hide div element onclick JS -->
  <script>
    function myFunction(divID) {
      var x = document.getElementById(divID);
      if (x.style.display === "none") {
        x.style.display = "block";
      } else {
        x.style.display = "none";
      }
    }
  </script>
  

</body>
</html>